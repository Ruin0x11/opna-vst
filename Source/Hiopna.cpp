#include "Hiopna.h"
#include <math.h>
#include <assert.h>

static const int kFrameCOuntSample = 578;
static unsigned char samples[kFrameCOuntSample] = { 0x27, 0x3f, 0x00, 0x57, 0x00, 0x41, 0x00, 0x4f, 0x27, 0x30, 0x07, 0xbf, 0x90, 0x00, 0x91, 0x00, 0x92, 0x00, 0x29, 0x87, 0x0f, 0xbf, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x0f, 0x80, 0x0f, 0xc0, 0x24, 0x70, 0x25, 0x00, 0x0a, 0x0b, 0x09, 0x0b, 0x03, 0x01, 0x02, 0xdf, 0x07, 0xbd, 0x08, 0x0b, 0x01, 0x01, 0x00, 0xdd, 0x07, 0xbc, 0xb6, 0xc0, 0xb2, 0x03, 0x32, 0x02, 0x42, 0x0f, 0x52, 0x1f, 0x62, 0x00, 0x72, 0x00, 0x82, 0x0f, 0x3a, 0x06, 0x4a, 0x28, 0x5a, 0x1f, 0x6a, 0x00, 0x7a, 0x00, 0x8a, 0x0f, 0x36, 0x04, 0x46, 0x28, 0x56, 0x1f, 0x66, 0x00, 0x76, 0x00, 0x86, 0x0f, 0x3e, 0x02, 0x4e, 0x00, 0x5e, 0x1f, 0x6e, 0x00, 0x7e, 0x00, 0x8e, 0x0f, 0xb2, 0x2c, 0x32, 0x34, 0x42, 0x31, 0x52, 0x18, 0x62, 0x0e, 0x72, 0x00, 0x82, 0xf7, 0x3a, 0x30, 0x4a, 0x04, 0x5a, 0x18, 0x6a, 0x04, 0x7a, 0x00, 0x8a, 0xf5, 0x36, 0x75, 0x46, 0x2f, 0x56, 0x18, 0x66, 0x10, 0x76, 0x00, 0x86, 0xf0, 0x3e, 0x72, 0x4e, 0x04, 0x5e, 0x18, 0x6e, 0x0a, 0x7e, 0x00, 0x8e, 0xf6, 0x4e, 0x13, 0x4a, 0x13, 0xb5, 0xc0, 0xb1, 0x03, 0x31, 0x02, 0x41, 0x0f, 0x51, 0x1f, 0x61, 0x00, 0x71, 0x00, 0x81, 0x0f, 0x39, 0x06, 0x49, 0x28, 0x59, 0x1f, 0x69, 0x00, 0x79, 0x00, 0x89, 0x0f, 0x35, 0x04, 0x45, 0x28, 0x55, 0x1f, 0x65, 0x00, 0x75, 0x00, 0x85, 0x0f, 0x3d, 0x02, 0x4d, 0x00, 0x5d, 0x1f, 0x6d, 0x00, 0x7d, 0x00, 0x8d, 0x0f, 0xb1, 0x2c, 0x31, 0x34, 0x41, 0x31, 0x51, 0x18, 0x61, 0x0e, 0x71, 0x00, 0x81, 0xf7, 0x39, 0x30, 0x49, 0x04, 0x59, 0x18, 0x69, 0x04, 0x79, 0x00, 0x89, 0xf5, 0x35, 0x75, 0x45, 0x2f, 0x55, 0x18, 0x65, 0x10, 0x75, 0x00, 0x85, 0xf0, 0x3d, 0x72, 0x4d, 0x04, 0x5d, 0x18, 0x6d, 0x0a, 0x7d, 0x00, 0x8d, 0xf6, 0x4d, 0x13, 0x49, 0x13, 0xa5, 0x3a, 0xa1, 0x65, 0x28, 0xf1, 0xb4, 0xc0, 0xb0, 0x03, 0x30, 0x02, 0x40, 0x0f, 0x50, 0x1f, 0x60, 0x00, 0x70, 0x00, 0x80, 0x0f, 0x38, 0x06, 0x48, 0x28, 0x58, 0x1f, 0x68, 0x00, 0x78, 0x00, 0x88, 0x0f, 0x34, 0x04, 0x44, 0x28, 0x54, 0x1f, 0x64, 0x00, 0x74, 0x00, 0x84, 0x0f, 0x3c, 0x02, 0x4c, 0x00, 0x5c, 0x1f, 0x6c, 0x00, 0x7c, 0x00, 0x8c, 0x0f, 0x24, 0xdf, 0x25, 0x01, 0xb0, 0x2c, 0x30, 0x34, 0x40, 0x31, 0x50, 0x18, 0x60, 0x0e, 0x70, 0x00, 0x80, 0xf7, 0x38, 0x30, 0x48, 0x04, 0x58, 0x18, 0x68, 0x04, 0x78, 0x00, 0x88, 0xf5, 0x34, 0x75, 0x44, 0x2f, 0x54, 0x18, 0x64, 0x10, 0x74, 0x00, 0x84, 0xf0, 0x3c, 0x72, 0x4c, 0x04, 0x5c, 0x18, 0x6c, 0x0a, 0x7c, 0x00, 0x8c, 0xf6, 0x4c, 0x13, 0x48, 0x13, 0xa4, 0x3a, 0xa0, 0x69, 0x28, 0xf0, 0x27, 0x35, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x0f, 0x80, 0x0f, 0xc0, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x0f, 0x80, 0x0f, 0xc0, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15, 0xa6, 0x3a, 0xa2, 0x61, 0x28, 0xf2, 0x27, 0x15, 0x27, 0x15, 0x0f, 0x80, 0x0f, 0xc0, 0x27, 0x15, 0x27, 0x15, 0x27, 0x15 };

void Punt(POPNA opna) {
	for (int i = 0; i < kFrameCOuntSample; i += 2) {
		unsigned char  reg = samples[i];
		unsigned char  data = samples[i + 1];
		opngen_setreg(&opna->opngen, 0, reg, data);
	}
}

void milliHertzToFnum(unsigned int milliHertz,
	UINT16 *fnum, UINT8 *block, unsigned int conversionFactor)
{
	// Special case to avoid divide by zero
	if (milliHertz == 0) {
		*block = 0; // actually any block will work
		*fnum = 0;
		return;
	}

	// Special case for frequencies too high to produce
	if (milliHertz > 6208431) {
		*block = 7;
		*fnum = 1023;
		return;
	}

	if (*block <= 7) {
		// We've already got a block, see if we can use that
		*fnum = ((unsigned long long)milliHertz << (20 - *block)) / (conversionFactor * 1000.0) + 0.5;
		if ((*fnum > 100) && (*fnum < 900)) {
			// Fits in the middle of the existing block pretty well, so let's keep it
			return;
		}
	}

	/// This formula will provide a pretty good estimate as to the best block to
	/// use for a given frequency.  It tries to use the lowest possible block
	/// number that is capable of representing the given frequency.  This is
	/// because as the block number increases, the precision decreases (i.e. there
	/// are larger steps between adjacent note frequencies.)  The 6M constant is
	/// the largest frequency (in milliHertz) that can be represented by the
	/// block/fnum system.
	//int invertedBlock = log2(6208431 / milliHertz);

	// Very low frequencies will produce very high inverted block numbers, but
	// as they can all be covered by inverted block 7 (block 0) we can just clip
	// the value.
	//if (invertedBlock > 7) invertedBlock = 7;
	//*block = 7 - invertedBlock;

	// This is a bit more efficient and doesn't need log2() from math.h
	if (milliHertz > 3104215) *block = 7;
	else if (milliHertz > 1552107) *block = 6;
	else if (milliHertz > 776053) *block = 5;
	else if (milliHertz > 388026) *block = 4;
	else if (milliHertz > 194013) *block = 3;
	else if (milliHertz > 97006) *block = 2;
	else if (milliHertz > 48503) *block = 1;
	else *block = 0;

	// Original formula
	//*fnum = milliHertz * pow(2, 20 - *block) / 1000 / conversionFactor + 0.5;

	// Slightly more efficient version
	*fnum = ((unsigned long long)milliHertz << (20 - *block)) / (conversionFactor * 1000.0) + 0.5;

	if ((*block == 7) && (*fnum > 1023)) {
		*fnum = 1023;
	}

	// Make sure the values come out within range
	//assert(*block >= 0);
	assert(*block <= 7);
	//assert(*fnum >= 0);
	//assert(*fnum < 1024);
	if (*fnum > 1024) *fnum = 1024; // TEMP
	return;
}

Hiopna::Hiopna()
{
	intermediateBufIdx = 0;
	opna_construct(&opna);
	opngen_initialize(44100);
	opngen_setvol(128);

	UINT nBaseClock = 3993600;
	for (int i = 0; i < NELEMENTS(fNumBlocks); i++)
	{
		fNumBlocks[i] = (UINT16)(440.0 * pow(2.0, (((double)i - 9.5) / 12.0) + 17.0) * 72.0 / (double)nBaseClock);
	}

	Reset();
}


Hiopna::~Hiopna()
{
	opna_destruct(&opna);
}

void Hiopna::Reset() {
	opna_reset(&opna, 0);
	Punt(&opna);
	for (int i = 0; i < INTERMEDIATE_BUF_N; i++) {
		memset(intermediateBuf[i], 0, INTERMEDIATE_BUF_SAMPLES);
	}
	ExtendChannel(true);
}

void Hiopna::Restore() {
	opna.s.base = 0x100;
}

void Hiopna::KeyOn(long freq) {
	UINT16 fNum = 0;
	UINT8 block = 0;
	milliHertzToFnum(freq, &fNum, &block, 49716);
	opngen_setreg(&opna.opngen, 0, 0xA0, (UINT8)fNum);
	UINT8 dat = (block << 3) | (fNum >> 8);
	opngen_setreg(&opna.opngen, 0, 0xA4, dat);
	opna.s.keyreg[1] = 0x3f;
	opngen_keyon(&opna.opngen, 0, 0x3f);
}

void Hiopna::KeyOff() {
	opna.s.keyreg[1] = 0x00;
	opngen_keyon(&opna.opngen, 0, 0x0);
}

void Hiopna::ExtendChannel(bool enable) {
	opna.s.extend = enable;
	if (enable)
	{
		opngen_setcfg(&opna.opngen, 6, OPN_STEREO | 0x007);
	}
	else
	{
		opngen_setcfg(&opna.opngen, 3, OPN_MONORAL | 0x007);
	}
}

void Hiopna::Generate(int length, float* buffer) {
	intermediateBufIdx = (intermediateBufIdx + 1) % INTERMEDIATE_BUF_N;
	SINT32 *iBuf = intermediateBuf[intermediateBufIdx];
	for (int i = 0; i < INTERMEDIATE_BUF_N; i++) {
		memset(intermediateBuf[i], 0, INTERMEDIATE_BUF_SAMPLES);
	}
	opngen_setreg(&opna.opngen, 0, 0x27, 0x0f);
	opngen_getpcm(&opna.opngen, iBuf, length);

	int indexL = 0;
	int indexR = 0;
	for (int i = 0; i < length*2; i++) {
		// Magic divisor taken from ZDoom wrapper for DOSBox emulator, line 892
		// https://github.com/rheit/zdoom/blob/master/src/oplsynth/dosbox/opl.cpp
		const float y = (float)(iBuf[i]) / 10240.0f;
		// http://stackoverflow.com/questions/427477/fastest-way-to-clamp-a-real-fixed-floating-point-value
		const float z = y < -1.0f ? -1.0f : y;
		const float out = z > 1.0f ? 1.0f : z;
		if (i % 2 == 0) {
			buffer[indexL++] = out;
		}
	}
}
